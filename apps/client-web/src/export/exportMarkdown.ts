import type { CanvasObject } from '../store/useCanvasStore';
import type { CommentThread } from '../store/useCommentStore';

/**
 * Export a meeting summary as Markdown.
 * Structures text objects and comments top-to-bottom, left-to-right.
 */
export function exportMarkdown(
  objects: Map<string, CanvasObject>,
  threads: Map<string, CommentThread>,
  boardName: string,
): string {
  const lines: string[] = [];

  lines.push(`# ${boardName || 'dexDraw Board'}`);
  lines.push('');
  lines.push(`*Exported: ${new Date().toLocaleString()}*`);
  lines.push('');

  // Text objects sorted top-to-bottom, left-to-right
  const textObjects = getSortedTextObjects(objects);
  lines.push(...getBoardContentMarkdown(textObjects));

  // Comments
  lines.push(...getCommentsMarkdown(threads));

  // Parking lot items
  lines.push(...getParkingLotMarkdown(objects));

  lines.push('---');
  lines.push('*Generated by dexDraw*');

  return lines.join('\n');
}

function getBoardContentMarkdown(textObjects: CanvasObject[]): string[] {
  const lines: string[] = [];
  if (textObjects.length === 0) return lines;

  lines.push('## Board Content');
  lines.push('');

  let lastRegion = '';
  for (const obj of textObjects) {
    const { region, label, text } = getTextObjectData(obj);

    // Group by region if present
    if (region && region !== lastRegion) {
      lines.push('');
      lines.push(`### ${label || region}`);
      lastRegion = region;
    } else if (label && !region) {
      lines.push(`**${label}**`);
    }

    if (text) {
      lines.push(`- ${text}`);
    }
  }
  lines.push('');
  return lines;
}

function getTextObjectData(obj: CanvasObject) {
  return {
    region: (obj.data.region as string) ?? '',
    label: (obj.data.label as string) ?? '',
    text: (obj.data.text as string) ?? (obj.data.chosenText as string) ?? '',
  };
}

function getCommentsMarkdown(threads: Map<string, CommentThread>): string[] {
  const lines: string[] = [];
  const threadList = Array.from(threads.values()).filter((t) => t.replies.length > 0);
  if (threadList.length > 0) {
    lines.push('## Comments');
    lines.push('');

    for (const thread of threadList) {
      const status = thread.resolved ? '(Resolved)' : '(Open)';
      lines.push(`### Comment ${status}`);
      lines.push('');

      for (const reply of thread.replies) {
        lines.push(`- **${reply.author}**: ${reply.text}`);
      }
      lines.push('');
    }
  }
  return lines;
}

function getParkingLotMarkdown(objects: Map<string, CanvasObject>): string[] {
  const lines: string[] = [];
  const parkedItems = Array.from(objects.values()).filter((obj) => obj.data?.parked === true);
  if (parkedItems.length > 0) {
    lines.push('## Parking Lot');
    lines.push('');
    for (const item of parkedItems) {
      const text = (item.data.text as string) ?? (item.data.label as string) ?? item.type;
      lines.push(`- ${text} (${item.id.slice(0, 8)})`);
    }
    lines.push('');
  }
  return lines;
}

function getSortedTextObjects(objects: Map<string, CanvasObject>): CanvasObject[] {
  return Array.from(objects.values())
    .filter((obj) => {
      const hasText = obj.data.text || obj.data.chosenText || obj.data.label;
      return hasText && obj.data.parked !== true;
    })
    .sort((a, b) => {
      const ay = (a.data.y as number) ?? 0;
      const by = (b.data.y as number) ?? 0;
      if (Math.abs(ay - by) < 50) {
        const ax = (a.data.x as number) ?? 0;
        const bx = (b.data.x as number) ?? 0;
        return ax - bx;
      }
      return ay - by;
    });
}

/** Trigger a Markdown file download. */
export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
