import type { CanvasObject } from '../store/useCanvasStore';
import type { CommentThread } from '../store/useCommentStore';

/**
 * Export a meeting summary as Markdown.
 * Structures text objects and comments top-to-bottom, left-to-right.
 */
export function exportMarkdown(
  objects: Map<string, CanvasObject>,
  threads: Map<string, CommentThread>,
  boardName: string,
): string {
  const lines: string[] = [];

  lines.push(`# ${boardName || 'dexDraw Board'}`);
  lines.push('');
  lines.push(`*Exported: ${new Date().toLocaleString()}*`);
  lines.push('');

  // Text objects sorted top-to-bottom, left-to-right
  const textObjects = getSortedTextObjects(objects);
  if (textObjects.length > 0) {
    lines.push('## Board Content');
    lines.push('');

    let lastRegion = '';
    for (const obj of textObjects) {
      const region = (obj.data.region as string) ?? '';
      const label = (obj.data.label as string) ?? '';
      const text = (obj.data.text as string) ?? (obj.data.chosenText as string) ?? '';

      // Group by region if present
      if (region && region !== lastRegion) {
        lines.push('');
        lines.push(`### ${label || region}`);
        lastRegion = region;
      } else if (label && !region) {
        lines.push(`**${label}**`);
      }

      if (text) {
        lines.push(`- ${text}`);
      }
    }
    lines.push('');
  }

  // Comments
  const threadList = Array.from(threads.values()).filter((t) => t.replies.length > 0);
  if (threadList.length > 0) {
    lines.push('## Comments');
    lines.push('');

    for (const thread of threadList) {
      const status = thread.resolved ? '(Resolved)' : '(Open)';
      lines.push(`### Comment ${status}`);
      lines.push('');

      for (const reply of thread.replies) {
        lines.push(`- **${reply.author}**: ${reply.text}`);
      }
      lines.push('');
    }
  }

  // Parking lot items
  const parkedItems = Array.from(objects.values()).filter(
    (obj) => obj.data?.parked === true,
  );
  if (parkedItems.length > 0) {
    lines.push('## Parking Lot');
    lines.push('');
    for (const item of parkedItems) {
      const text = (item.data.text as string) ?? (item.data.label as string) ?? item.type;
      lines.push(`- ${text} (${item.id.slice(0, 8)})`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by dexDraw*');

  return lines.join('\n');
}

function getSortedTextObjects(objects: Map<string, CanvasObject>): CanvasObject[] {
  return Array.from(objects.values())
    .filter((obj) => {
      const hasText = obj.data.text || obj.data.chosenText || obj.data.label;
      return hasText && obj.data.parked !== true;
    })
    .sort((a, b) => {
      const ay = (a.data.y as number) ?? 0;
      const by = (b.data.y as number) ?? 0;
      if (Math.abs(ay - by) < 50) {
        const ax = (a.data.x as number) ?? 0;
        const bx = (b.data.x as number) ?? 0;
        return ax - bx;
      }
      return ay - by;
    });
}

/** Trigger a Markdown file download. */
export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
